<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/black.css" />
    <link rel="stylesheet" href="dist/theme/black.css" />
    <link rel="stylesheet" href="./assets/css/styles.css" />
    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"
      integrity="sha512-dLxUelApnYxpLt6K2iomGngnHO83iUvZytA3YjDUCjT0HDOHKXnVYdf3hU4JjM8uEhxf9nD1/ey98U3t2vZ0qQ=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer">
    </script>
    <script src="assets/js/gl-matrix.js"></script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section class="first-slide">
          <div>WebGL and Three.js</div>
          <div class="rs-school-logo-wrap">
            <img
              src="./assets/images/rs-school-logo.svg"
              alt="RSSchool logo"
              class="rs-school-logo"
            />
            <small>2021</small>
          </div>
          <aside class="notes">
            Hello. Today I'd like to talk about WebGL and three.js.
            We'll see how to render graphics using those technologies and compare them.
            First, let's find out what WebGL is.
            It's a standard defining JS API for instructing the GPU to render objects.
            In browsers this API is implemented
            in the form of WebGLRenderingContext - a special object
            accessible from canvas elements.
            We'll see how to use it shortly.
          </aside>
        </section>
        <section>
          <section>
            <div>WebGL - Javascript API for rendering 3D graphics</div>
            <div class="r-stack">
              <div class="fragment fragment-wrap">
                <iframe
                  data-src="https://webglsamples.org/electricflower/electricflower.html"
                  data-preload
                  width="600"
                  height="450"
                ></iframe>
              </div>
              <div class="fragment fragment-wrap">
                <iframe
                  data-src="https://webglsamples.org/aquarium/aquarium.html"
                  data-preload
                  width="600"
                  height="450"
                ></iframe>
              </div>
              <div class="fragment fragment-wrap">
                <img
                  data-src="./assets/images/planettoweb.png"
                  width="600"
                  height="450"
                ></img>
              </div>
              <div class="fragment fragment-wrap">
                <iframe
                  frameborder="0"
                  data-src="http://www.randelshofer.ch/webgl/rubikscube/"
                  data-preload
                  width="450"
                  height="300"
                ></iframe>
              </div>
              <div class="fragment fragment-wrap">
                <iframe
                  data-src="http://media.tojicode.com/q3bsp/"
                  data-preload
                  width="450"
                  height="300"
                ></iframe>
              </div>
            </div>
            <aside class="notes">
              Here are some examples of what can be done using WebGL.
              Here you see some light animation.
              Now you can see moving objects.
              This is an animation of the Solar System.
              The Rubik Cube, it's interactive.
              And a demo of a game resembling Quake.
            </aside>
          </section>
        </section>
        <section>
          <div>History of WebGL</div>
          <aside class="notes">
            Now let's touch on the history of WebGL.
          </aside>
        </section>
        <section>
          <section>
            <ul>
              <div><b>1992</b></div>
              <li>Silicon Graphics, Inc. releases OpenGL 1.0</li>
              <li>
                OpenGL Architecture Review Board is created to maintain the
                specification
              </li>
            </ul>
            <div class="logo-wrap">
              <img src="./assets/images/opengl-logo.png" alt="OpenGL logo" />
            </div>
            <aside class="notes">
              In 1992 OpenGL was released by Silicon Graphics, which later became the basis for other standards,
              one of which - WebGL.
              Over the years some updates have been released. The current version is 4.6.
            </aside>
          </section>
          <section class="section-align-left">
            <ul>
              <div><b>2003</b></div>
              <li>OpenGL ES 1.0 released</li>
            </ul>
            <div class="logo-wrap">
              <img
                src="./assets/images/opengl-es-logo.png"
                alt="OpenGL ES logo"
              />
            </div>
            <aside class="notes">
              In 2003 OpenGL ES (meaning embedded systems) was developed.
              Simply put, it was subset of OpenGL aimed at devices such as smartphones and video game consoles.
            </aside>
          </section>
          <section>
            <ul>
              <div><b>2006</b></div>
              <li>
                OpenGL Architecture Review Board transfers control of OpenGL to
                <b>Khronos group</b>
              </li>
              <li>
                Vladimir Vukicevic starts working on an extension of OpenGL ES -
                <b>WebGL</b>
              </li>
            </ul>
            <div class="logo-wrap">
              <img
                src="./assets/images/khronos-logo.png"
                alt="Khronos Group logo"
              />
            </div>
            <aside class="notes">
              In 2006 Vladimir Vukicevic started working on an extension of OpenGL ES, which later turned into WebGL.
            </aside>
          </section>
          <section class="section-align-left">
            <ul>
              <div><b>2011</b></div>
              <li>WebGL 1.0 released</li>
            </ul>
            <div class="logo-wrap">
              <img src="./assets/images/webgl-logo.png" alt="WebGL logo" />
            </div>
            <aside class="notes">
              In 2011, WebGL 1.0 was released.
            </aside>
          </section>
          <section class="section-align-left">
            <ul>
              <div><b>2017</b></div>
              <li>WebGL 2.0 released</li>
            </ul>
            <div class="logo-wrap">
              <img src="./assets/images/webgl-logo.png" alt="WebGL logo" />
            </div>
            <aside class="notes">
              Its current version is 2.0 which was released in 2017.
            </aside>
          </section>
        </section>
        <section>
          <div>WebGL pipeline</div>
          <div class="r-stack">
            <div class="fragment">
              <img
                data-src="./assets/images/webgl-pipeline-simple.png"
                width="450"
                height="300"
                alt="WebGL pipeline"
              />
            </div>
            <div class="fragment">
              <img
                data-src="./assets/images/webgl-pipeline-alt.jpg"
                width="450"
                height="300"
                alt="WebGL pipeline"
              />
            </div>
          </div>
          <aside class="notes">
            There is a process used by the API to render objects.
            Basically, we need a mesh which is a shape composed of triangles.
            Each triangle consists of points in 3D.
            So we compose those points in an array and send them to special functions
            written in the shading language.
            The first function is called vertex shader. It calculates the final position of a vertex.
            The second one is called fragment shader - it deals with colors.
            As you can see here, when the processing is done, the data is stored in frame buffer,
            which is a memory area in GPU, from where it's displayed on the screen.
          </aside>
        </section>
        <section>
          <div>Working with WebGL</div>
          <aside class="notes">
            Let's see how to use WebGL.
          </aside>
        </section>
        <section>
          <canvas class="canvas-example-1" width="600" height="450"></canvas>
          <aside class="notes">
            Suppose we want to draw a square on the canvas.
          </aside>
        </section>
        <section>
          <div>Vertex shader</div>
          <pre>
						<code data-trim  data-line-numbers="1|2|4|6|7">
              #version 300 es
              precision mediump float;
              
              in vec3 aVertexPosition;
              
              void main(void) {
                gl_Position = vec4(aVertexPosition, 1.0);
              }
						</code>
          </pre>
          <aside class="notes">
            First, let's define our vertex shader.
            The first line says we should use a particular version of the language - OpenGL ES SL 3.0.
            Here, we say that floating point arithmetic should be of medium precision.
            Here, we declare an input variable - actually, a vertex position.
            You can see the main function, just like in C.
            And inside we use a reserved keyword,
            gl_Position, where the final vertex position will be stored.
            In our case, we don't do anything with it, just take the input and store it.
          </aside>
        </section>
        <section>
          <div>Fragment shader</div>
          <pre>
						<code data-trim  data-line-numbers="4|7">
              #version 300 es
              precision mediump float;
              
              out vec4 fragColor;
              
              void main(void) {
                fragColor = vec4(0.7, 0.7, 0.5, 1.0);
              }
						</code>
          </pre>
          <aside class="notes">
            The fragment shader is even simpler.
            We just declare the output value and store a hardcoded value there.
          </aside>
        </section>
        <section>
          <div>Working with the API using JS</div>
          <aside class="notes">
            We need to use JS to interact with the API.
          </aside>
        </section>
        <section>
          <pre>
						<code data-trim  data-line-numbers="1-2|4-6">
              const canvas = document.querySelector('.canvas');
              const ctx = canvas.getContext('webgl2');

              ctx.clearColor(0, 0, 0, 1.0);
              ctx.clear(ctx.COLOR_BUFFER_BIT);
              ctx.viewport(0, 0, 0, 0);
						</code>
          </pre>
          <aside class="notes">
            So, there's a canvas. We get a context from there.
            Here, we specify that we should use WebGL 2.0.
            Then we fill the canvas with the black color.
          </aside>
        </section>
        <section>
          <pre>
						<code data-trim data-line-numbers="1-7|8">
              const vertices = 
              [
                -0.5, 0.5, 0,
                -0.5, -0.5, 0,
                0.5, -0.5, 0,
                0.5, 0.5, 0
              ];
              const indices = [0, 1, 2, 0, 2, 3];
						</code>
          </pre>
          <aside class="notes">
            We define vertices in clipspace coordinates. They span from -1 to 1.
            Here every 3 values specify x, y and z coordinates of a single vertex.
            Also, we use an array of indices, which specify how we compose triangles
            from vertices. So if we want to draw a square, we need 2 triangles, which
            we specify using the indices.
          </aside>
        </section>
        <section>
          <pre>
						<code data-trim  data-line-numbers="1-5|6-10">
              const vertexBuffer = ctx.createBuffer();
              ctx.bindBuffer(ctx.ARRAY_BUFFER, vertexBuffer);
              ctx.bufferData(ctx.ARRAY_BUFFER,
                             new Float32Array(vertices),
                             ctx.STATIC_DRAW);
              const indexBuffer = ctx.createBuffer();
              ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, indexBuffer);
              ctx.bufferData(ctx.ELEMENT_ARRAY_BUFFER,
                             new Uint16Array(indices),
                             ctx.STATIC_DRAW);
						</code>
          </pre>
          <aside class="notes">
            After that we set up buffers in the GPU memory using typed JS arrays.
            One buffer is for vertices and the other one is for indices
          </aside>
        </section>
        <section>
          <pre>
						<code data-trim  data-line-numbers="1-5|6-9">
              const program = initProgram(
                ctx,
                vertexShader,
                fragmentShader
              );
              const aVertexPositionAttribute = ctx.getAttribLocation(
                program,
                'aVertexPosition'
              );
						</code>
          </pre>
          <aside class="notes">
            Then we instantiate a program.
            Here's a helper function incapsulating some irrelevant things
            like getting shader functions texts from script elements in the page
            and linking them to a special object, which will be the "program".
            Then we specify that there's going to be an input variable
            in the vertex shader, vertex positions.
          </aside>
        </section>
        <section>
          <pre>
						<code data-trim  data-line-numbers="1|2-6">
              ctx.bindBuffer(ctx.ARRAY_BUFFER, vertexBuffer);
              ctx.vertexAttribPointer(
                aVertexPositionAttribute,
                3, ctx.FLOAT, false, 0, 0
              );
              ctx.enableVertexAttribArray(aVertexPositionAttribute);
						</code>
          </pre>
          <aside class="notes">
            Then we enable that variable.
          </aside>
        </section>
        <section>
          <pre>
						<code data-trim  data-line-numbers="1|2|7-8">
              ctx.drawElements(
                ctx.TRIANGLES,
                indices.length,
                ctx.UNSIGNED_SHORT,
                0);

              ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
              ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
						</code>
          </pre>
          <aside class="notes">
            When all is set, we are ready to draw our object.
            Here, we use a mode for rendering triangles,
            but points or lines could also be used.
            When we are done, we set the buffers to null.
          </aside>
        </section>
        <section>
          <canvas class="canvas-example-1-copy" width="600" height="450"></canvas>
          <aside class="notes">
            Some more complex things can be done...
          </aside>
        </section>
        <section>
          <div>Image translation</div>
          <canvas class="canvas-example-2" width="600" height="450"></canvas>
          <aside class="notes">
            like translating vertices and coloring them with gradients...
          </aside>
        </section>
        <section>
          <div>Image rotation</div>
          <canvas class="canvas-example-3" width="600" height="450"></canvas>
          <aside class="notes">
            rotating things...
          </aside>
        </section>
        <section>
          <div>Image animation in 3D</div>
          <canvas class="canvas-example-4" width="600" height="450"></canvas>
          <aside class="notes">
            ...and drawing objects in 3D.
            That requires some linear algebra.
            In this case, we should provide a transformation matrix,
            which will control the camera and how we see this cube.
          </aside>
        </section>
        <section>
          <div>Browsers supporting WebGL2</div>
          <ul>
            <li>Firefox 51+</li>
            <li>Chrome 56+</li>
            <li>Chrome for Android 64+</li>
            <li>Edge 79+</li>
            <li>Safari 10.1+ (as an experimental feature)</li>
          </ul>
          <aside class="notes">
            Nowadays browsers provide good support for WebGL.
            As you can see, all the major ones implement the API.
          </aside>
        </section>
        <section>
          <div>Three.js</div>
          <div>Abstracts away some details of WebGL</div>
          <aside class="notes">
            Now let's turn our attention to Three.js.
            Basically, it's a library that provides a convenient interface to work with WebGL.
          </aside>
        </section>
        <section>
          <div>Three.js pipeline</div>
          <img data-src="./assets/images/three-js-pipeline.png" alt="Three.js pipeline" width="450" height="300">
          <aside class="notes">
            There are objects such as a camera, scene, objects to be rendered (meshes)
            and renderer - a special object that controls how to render things.
            We can use JS - the function requestAnimationFrame. In the callback we can render
            the scene and change the parameters of our animation.
          </aside>
        </section>
        <section>
          Working with Three.js
          <aside class="notes">
            Now, suppose we want to draw a square again.
          </aside>
        </section>
        <section>
          <canvas class="canvas-example-5" width="600" height="450"></canvas>
          <aside class="notes">
            Now, suppose we want to draw a square again.
          </aside>
        </section>
        <section>
          <pre>
						<code data-trim  data-line-numbers="1|3-4|6-7|8-10">
              const renderer = new THREE.WebGLRenderer({ canvas });

              const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 5);
              camera.position.z = 5;
            
              const scene = new THREE.Scene();
              scene.background = new THREE.Color(0x000);
              const light = new THREE.DirectionalLight(0xffffff, 1);
              light.position.set(-1, 2, 4);
              scene.add(light);
						</code>
          </pre>
          <aside class="notes">
            We instantiate a renderer, camera, set up a scene, fill it with the black color,
            declare a light source, add it to the scene.
          </aside>
        </section>
        <section>
          <pre>
						<code data-trim  data-line-numbers="1|2-4|5-6|7">
              const geometry = new THREE.BoxGeometry(1, 1, 1);
              const material = new THREE.MeshPhongMaterial(
                { color: 0x44aa88 }
              );
              const square = new THREE.Mesh(geometry, material);
              scene.add(square);
              renderer.render(scene, camera);
						</code>
          </pre>
          <aside class="notes">
            Then we create a square (actually, a cube, but we only see one face).
            Then we render.
          </aside>
        </section>
        <section>
          <canvas class="canvas-example-5-copy" width="600" height="450"></canvas>
          <aside class="notes">
            The result is the same as it would be in WebGL, but much simpler.
          </aside>
        </section>
        <section>
          <div>Three.js animation</div>
          <canvas class="canvas-example-6" width="600" height="450"></canvas>
          <aside class="notes">
            More complex things can be done too, like animation, adding textures, adding light sources
            and the like.
          </aside>
        </section>
        <section>
          <div>Other solutions</div>
          <ul>
            <li>
              <a href="https://github.com/senchalabs/philogl">PhiloGL </a>
            </li>
            <li>
              <a href="https://github.com/supereggbert/GLGE">GLGE</a>
            </li>
            <li>
              <a href="https://www.babylonjs.com/">Babylon.js </a>
            </li>
          </ul>
          <aside class="notes">
            Three.js is not the only library that provides a wrapper for WebGL.
            There are some others like PhiloGL, GLGE, Babylon.js.
          </aside>
        </section>
        <section>
          <div>Useful links</div>
          <ul>
            <li>
              <a href="https://webgl2fundamentals.org"
                >Resource for learning WebGL
              </a>
            </li>
            <li>
              <a href="https://github.com/mrdoob/three.js"
                >Three.js repository
              </a>
            </li>
            <li>
              <a href="https://github.com/KhronosGroup/WebGL">
                WebGL repository for the WebGL by The Khronos Group
              </a>
            </li>
            <li>
              <a href="https://get.webgl.org/get-a-webgl-implementation/"
                >Platforms supporting WebGL
              </a>
            </li>
            <li>
              <a href="https://github.com/toji/gl-matrix"
                >gl-matrix - JS vector and matrix library
              </a>
            </li>
            <li>
              <a
                href="http://my2iu.blogspot.com/2011/11/webgl-pre-tutorial-part-1.html"
                >Introductory article on WebGL
              </a>
            </li>
            <li>
              <a href="https://threejsfundamentals.org"
                >Resource for learning Three.js
              </a>
            </li>
            <li>
              <a
                href="https://www.packtpub.com/product/real-time-3d-graphics-with-webgl-2-second-edition/9781788629690"
                >Practice-oriented book on WebGL
              </a>
            </li>
          </ul>
          <aside class="notes">
            So here's a list of links for further research...
          </aside>
        </section>
        <section>
          <div>Examples of using WebGL</div>
          <ul>
            <li>
              <a href="https://bookcase.chromeexperiments.com"
                >GoogleBooks bookshelf</a
              >
            </li>
            <li>
              <a href="https://www.sakharov.space"
                >Online museum in memory of Andrey Sakharov</a
              >
            </li>
            <li>
              <a href="http://www.randelshofer.ch/webgl/rubikscube"
                >The Rubik Cube game</a
              >
            </li>
            <li>
              <a href="https://webglsamples.org"> Various WebGL demos</a>
            </li>

            <li>
              <a href="http://planetoweb.net/app">The Solar System Animation</a>
            </li>
            <li>
              <a href="http://media.tojicode.com/q3bsp">FPS demo</a>
            </li>
            <li>
              <a href="https://threejs.org/examples">Various Three.js demos </a>
            </li>
          </ul>
          <aside class="notes">
            ...and a list of more animations.
          </aside>
        </section>
        <section>Thanks for watching!</section>
      </div>
    </div>
    <script src="assets/js/util.js"></script>
    <script src="assets/js/example1.js"></script>
    <script src="assets/js/example2.js"></script>
    <script src="assets/js/example3.js"></script>
    <script src="assets/js/example4.js"></script>
    <script src="assets/js/example5.js"></script>
    <script src="assets/js/example6.js"></script>
    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
